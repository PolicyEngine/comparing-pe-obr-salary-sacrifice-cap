<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>UK Constituency Map - Salary Sacrifice Cap Impact</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: white;
        font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
      }
      svg {
        display: block;
      }
      .tooltip {
        position: fixed;
        background: white;
        padding: 10px 14px;
        border-radius: 6px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        pointer-events: none;
        opacity: 0;
        font-size: 13px;
        z-index: 1001;
      }
      .tooltip strong {
        display: block;
        margin-bottom: 4px;
      }
      .tooltip .value {
        font-weight: 600;
      }
      .loss {
        color: #6B7280;
      }
      .gain {
        color: #059669;
      }
      .zoom-controls {
        position: absolute;
        top: 20px;
        left: 0px;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .zoom-btn {
        width: 32px;
        height: 32px;
        border: 1px solid #ccc;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }
      .zoom-btn:hover {
        background: #f0f0f0;
      }
      .search-container {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
      }
      .search-input {
        width: 200px;
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 13px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        outline: none;
      }
      .search-input:focus {
        border-color: #6B7280;
      }
      .search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ccc;
        border-top: none;
        border-radius: 0 0 6px 6px;
        max-height: 200px;
        overflow-y: auto;
        display: none;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .search-result-item {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 12px;
        border-bottom: 1px solid #eee;
      }
      .search-result-item:hover {
        background: #f5f5f5;
      }
      .legend {
        position: absolute;
        bottom: 20px;
        right: 10px;
        padding: 5px;
        font-size: 12px;
        z-index: 1000;
      }
      .legend-bar {
        width: 120px;
        height: 12px;
        border-radius: 2px;
      }
      .legend-labels {
        display: flex;
        justify-content: space-between;
        font-size: 10px;
        color: #666;
        margin-top: 4px;
      }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="search-container">
      <input type="text" class="search-input" id="search-input" placeholder="Search constituency..." autocomplete="off" />
      <div class="search-results" id="search-results"></div>
    </div>
    <div class="zoom-controls">
      <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
      <button class="zoom-btn" id="zoom-out" title="Zoom Out">&minus;</button>
      <button class="zoom-btn" id="zoom-reset" title="Reset">&#10226;</button>
    </div>
    <div class="legend">
      <div class="legend-bar" id="legend-bar"></div>
      <div class="legend-labels">
        <span id="legend-min"></span>
        <span id="legend-max"></span>
      </div>
    </div>
    <svg id="map"></svg>
    <div class="tooltip" id="tooltip"></div>
    <script>
      async function init() {
        const [csvText, geojson] = await Promise.all([
          fetch('/data/constituency.csv').then(r => r.text()),
          fetch('/data/constituencies.geojson').then(r => r.json()),
        ]);

        function parseCSVLine(line) {
          const cols = [];
          let cur = '', inQuotes = false;
          for (let i = 0; i < line.length; i++) {
            const ch = line[i];
            if (ch === '"') { inQuotes = !inQuotes; }
            else if (ch === ',' && !inQuotes) { cols.push(cur); cur = ''; }
            else { cur += ch; }
          }
          cols.push(cur);
          return cols;
        }

        // Parse constituency CSV — single year, no year slider needed
        const csvRows = csvText.trim().split('\n').slice(1);
        const dataByCode = {};
        csvRows.forEach(line => {
          const cols = parseCSVLine(line);
          const code = cols[1];
          const name = cols[2];
          const avg_change = parseFloat(cols[3]);
          dataByCode[code] = { name, avg_change };
        });

        const w = window.innerWidth, h = window.innerHeight;
        const svg = d3.select('#map').attr('width', w).attr('height', h);
        const g = svg.append('g');
        const tooltip = d3.select('#tooltip');

        // Color scale — light blue to dark blue for losses
        const colorScale = d3.scaleLinear().domain([0, -600]).range(['#dbeafe', '#1e3a5f']).clamp(true);

        // Legend
        document.getElementById('legend-bar').style.background = 'linear-gradient(to right, #dbeafe, #1e3a5f)';
        document.getElementById('legend-min').textContent = '\u00a30';
        document.getElementById('legend-max').textContent = '\u00a3600 loss';

        const getCode = f => f.properties.c || f.properties.GSScode || '';
        const getName = f => f.properties.n || f.properties.Name || '';

        // Include all constituencies (England, Wales, Scotland, NI)

        // Calculate bounds
        const coords = geojson.features.flatMap(f => {
          const geom = f.geometry;
          if (geom.type === 'Polygon') return geom.coordinates[0];
          if (geom.type === 'MultiPolygon') return geom.coordinates.flatMap(p => p[0]);
          return [];
        });
        const xMin = d3.min(coords, d => d[0]);
        const xMax = d3.max(coords, d => d[0]);
        const yMin = d3.min(coords, d => d[1]);
        const yMax = d3.max(coords, d => d[1]);

        const s = Math.min((w - 40) / (xMax - xMin), (h - 40) / (yMax - yMin));
        const ox = (w - (xMax - xMin) * s) / 2 - 100;
        const oy = (h - (yMax - yMin) * s) / 2 + 100;

        const proj = d3.geoTransform({
          point: function (x, y) {
            this.stream.point((x - xMin) * s + ox, h - ((y - yMin) * s + oy));
          },
        });
        const path = d3.geoPath().projection(proj);

        // Draw
        const paths = g
          .selectAll('path')
          .data(geojson.features)
          .enter()
          .append('path')
          .attr('d', path)
          .attr('stroke', '#fff')
          .attr('stroke-width', 0.3)
          .attr('fill', d => {
            const code = getCode(d);
            const info = dataByCode[code];
            if (info && info.avg_change !== 0) return colorScale(info.avg_change);
            return '#f3f4f6';
          })
          .on('mouseover', function (event, d) {
            const code = getCode(d);
            const name = getName(d);
            const info = dataByCode[code];

            d3.select(this).attr('stroke', '#000').attr('stroke-width', 1.5);

            if (info && info.avg_change !== 0) {
              const absVal = Math.abs(info.avg_change).toFixed(0);
              const cssClass = info.avg_change < 0 ? 'loss' : 'gain';
              const label = info.avg_change < 0 ? 'loss' : 'gain';
              tooltip.html(`
                <strong>${name}</strong>
                <div>Average ${label}: <span class="value ${cssClass}">\u00a3${absVal}</span></div>
              `);
            } else {
              tooltip.html(`<strong>${name}</strong><div>No data</div>`);
            }

            tooltip.style('opacity', 1)
              .style('left', event.clientX + 15 + 'px')
              .style('top', event.clientY - 10 + 'px');
          })
          .on('mouseout', function () {
            d3.select(this).attr('stroke', '#fff').attr('stroke-width', 0.3);
            tooltip.style('opacity', 0);
          });

        // Zoom
        const zoom = d3.zoom().scaleExtent([0.5, 10]).on('zoom', e => g.attr('transform', e.transform));
        svg.call(zoom);
        d3.select('#zoom-in').on('click', () => svg.transition().call(zoom.scaleBy, 1.5));
        d3.select('#zoom-out').on('click', () => svg.transition().call(zoom.scaleBy, 0.67));
        d3.select('#zoom-reset').on('click', () => svg.transition().call(zoom.transform, d3.zoomIdentity));

        // Search
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        const constituencies = geojson.features
          .map(f => ({ name: getName(f), code: getCode(f) }))
          .filter(c => c.name);

        searchInput.addEventListener('input', () => {
          const query = searchInput.value.toLowerCase();
          if (query.length < 2) { searchResults.style.display = 'none'; return; }

          const matches = constituencies.filter(c => c.name.toLowerCase().includes(query)).slice(0, 10);
          if (matches.length > 0) {
            searchResults.innerHTML = matches.map(c => {
              const info = dataByCode[c.code];
              let changeText = 'No data';
              if (info && info.avg_change !== 0) {
                const absVal = Math.abs(info.avg_change).toFixed(0);
                changeText = info.avg_change < 0 ? `\u00a3${absVal} loss` : `\u00a3${absVal} gain`;
              }
              const cssClass = info && info.avg_change < 0 ? 'loss' : 'gain';
              return `<div class="search-result-item" data-code="${c.code}">${c.name} <small class="${cssClass}">${changeText}</small></div>`;
            }).join('');
            searchResults.style.display = 'block';
          } else {
            searchResults.style.display = 'none';
          }
        });

        searchResults.addEventListener('click', e => {
          if (!e.target.classList.contains('search-result-item')) return;
          const code = e.target.dataset.code;
          const feature = geojson.features.find(f => getCode(f) === code);
          if (!feature) return;

          const bounds = path.bounds(feature);
          const dx = bounds[1][0] - bounds[0][0];
          const dy = bounds[1][1] - bounds[0][1];
          const x = (bounds[0][0] + bounds[1][0]) / 2;
          const y = (bounds[0][1] + bounds[1][1]) / 2;
          const scale = Math.min(8, 0.9 / Math.max(dx / w, dy / h));
          const translate = [w / 2 - scale * x, h / 2 - scale * y];

          svg.transition().duration(750)
            .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale))
            .on('end', () => {
              const info = dataByCode[code];
              const name = getName(feature);

              paths
                .attr('stroke', d => getCode(d) === code ? '#000' : '#fff')
                .attr('stroke-width', d => getCode(d) === code ? 2 : 0.3);

              if (info && info.avg_change !== 0) {
                const absVal = Math.abs(info.avg_change).toFixed(0);
                const cssClass = info.avg_change < 0 ? 'loss' : 'gain';
                const label = info.avg_change < 0 ? 'loss' : 'gain';
                tooltip.html(`
                  <strong>${name}</strong>
                  <div>Average ${label}: <span class="value ${cssClass}">\u00a3${absVal}</span></div>
                `);
              } else {
                tooltip.html(`<strong>${name}</strong><div>No data</div>`);
              }
              tooltip.style('opacity', 1)
                .style('left', w / 2 + 50 + 'px')
                .style('top', h / 2 - 30 + 'px');
            });

          searchResults.style.display = 'none';
          searchInput.value = e.target.textContent.split(' \u00a3')[0].trim();
        });
      }

      init();
    </script>
  </body>
</html>
